#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int get(int r)         //得到第r轮的移位数 
{
    int i;
    if (r == 1 || r == 2 || r == 9 || r == 16) {
        i = 1;
    }
    else {
        i = 2;
    }
    return i;
}

void yihuo(int* a, const int* b, int num)      //异或 
{
    int i;
    for (i = 0; i < num; i++)
    {
        if (a[i] == b[i]) {//相同为0 
            a[i] = 0;
        }
        else {//不同为1 
            a[i] = 1;
        }
    }
}

void fuck(int a[64], const int b[64], int n) {
    for (int i = 0; i < n; i++) {
        a[i] = b[i];
    }
}
void left_move(int s[28], int s1[28], int n) //左移
{
    int i, t, temp;
    fuck(s, s1, 28);
    for (i = 0; i < n; i++) {
        temp = s[0];
        for (t = 0; t < 27; t++) {
            s[t] = s[t + 1];
        }
        s[27] = temp;//原先的左半部分第一位赋给最后一位 
    }
}
void exchange(const int* a, int* b, const int* biao, int n)    //置换 
{
    int i, loc;
    for (i = 0; i < n; i++)//输入的第biao[i]位是输出的第i位 
    {
        loc = biao[i];
        b[i] = a[loc - 1];
    }
}

void erzhuanshi(const int* a,unsigned char* b, int n)
// a是二进制数组，b是存放十六进制的数组，n是二进制数组的大小
{
    int i, j;
    n = n / 8;
    for (i = 0; i < n; i++)
    {
        j = 128 * a[8 * i] + 64 * a[8 * i + 1] + 32 * a[8 * i + 2] + 16 * a[8 * i + 3] + 8 * a[8 * i + 4] + 4 * a[8 * i + 5] + 2 * a[8 * i + 6] + 1 * a[8 * i + 7];//先转换为十进制 
        b[i] = (char)j;//转换为char型字符 
    }
}
void shizhuaner(int* a, int x, int i, int n)
// a是存放二进制的数组，x是需要进行转换的十进制数，i是第i个十进制数，n是数组大小
{
    int j; n = n / 8; j = n - 1;
    do {
        a[i * n + j] = x % 2;//x的2进制最后一位，0or1 
        x = x / 2;//右移 
        j--;
    } while (x != 0);
    while (j >= 0)//如果右移后出现000....的情况 
    {
        a[i * n + j] = 0;
        j--;
    }
}



void s_box(int a[32], const int b[48])         //S盒
{
    int i, r, c, s;
    int s1[4][16] = { { 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7 },{ 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8 },{ 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0 },{ 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 } },
            s2[4][16] = { { 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10 },{ 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5 },{ 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15 },{ 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9 } },
            s3[4][16] = { { 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8 },{ 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1 },{ 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7 },{ 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12 } },
            s4[4][16] = { { 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15 },{ 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9 },{ 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 3 },{ 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14 } },
            s5[4][16] = { { 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9 },{ 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6 },{ 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14 },{ 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3 } },
            s6[4][16] = { { 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11 },{ 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8 },{ 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6 },{ 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13 } },
            s7[4][16] = { { 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1 },{ 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6 },{ 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2 },{ 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12 } },
            s8[4][16] = { { 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7 },{ 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2 },{ 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8 },{ 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 } };
    for (i = 0; i < 8; i++)
    {
        r = 2 * b[6 * i] + b[6 * i + 5];//第一位和最后一位构建行  
        c = 8 * b[6 * i + 1] + 4 * b[6 * i + 2] + 2 * b[6 * i + 3] + b[6 * i + 4];//中间四位构建列 
        label:
        switch (i) //选择盒子
        {
            case 0:s = s1[r][c]; break;
            case 1:s = s2[r][c]; break;
            case 2:s = s3[r][c]; break;
            case 3:s = s4[r][c]; break;
            case 4:s = s5[r][c]; break;
            case 5:s = s6[r][c]; break;
            case 6:s = s7[r][c]; break;
            case 7:s = s8[r][c]; break;
            default: cout << "Error!" << endl;
                goto label;
        }
        shizhuaner(a, s, i, 32); //转化为二进制 
    }
}


int  main()
{
    // unsigned char a[8];//明文
    unsigned char a[65536];//明文
    for(int i=0;i<65536;i++)
    {
        a[i]=0;
    }
    unsigned char b[8];//密钥
    int	e[48] = { 32, 1, 2, 3, 4, 5,4, 5, 6, 7, 8, 9,8, 9, 10, 11, 12, 13,12, 13, 14, 15, 16, 17,16, 17, 18, 19, 20, 21,20, 21, 22, 23, 24, 25,24, 25, 26, 27, 28, 29,28, 29, 30, 31, 32, 1 };    //E盒 
    int	p[32] = { 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25 };     //P盒 
    int m_a[64] = { 0 };
    int m_b[64];          //IP置换前后的明文 
    int s_a[64] = { 0 };
    int s_b[56];          //置换1前后的二进制密钥 
    int r;            //轮数
    [[maybe_unused]] int miwen[8] = { 0 };   //最终密文
    int i;
    [[maybe_unused]] int j;
    int key_l[17][28];//16轮密钥 
    int key_r[17][28];
    int key_2[17][56];
    int zhihuan1[56] = { 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 };      //置换1 
    int IP[64] = { 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7 };    //IP置换 
    int IP_1[64] = { 40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25 };    //IP_1置换

    cout<<"* -------------- - DES加密-------------- *"<<endl<<endl;
    printf("请输入需要加密的明文:\n");//将明文转化为2进制
    // for (i=0;i<8;i++)
    // {
    //     cin>>a[i];
    //     shizhuaner(m_a,(int)a[i],i,64);
    // }
    cin>>a;
    for (i=0;i<strlen((char*)a);i++)
    {
        shizhuaner(m_a,(int)a[i],i,64);
    }

    cout<<endl<<"请输入加密的密钥:"<<endl;//将密钥转为2进制
    for (i=0;i<8;i++)
    {
        cin>>b[i];
        shizhuaner(s_a,(int)b[i],i,64);

    }
    exchange(m_a, m_b, IP, 64); //明文进行初始置换 
    int min_l[17][32];
    int min_r[17][32];
    for (i = 0; i < 32; i++)//明文第0轮的左半部分 
        min_l[0][i] = m_b[i];
    for (i = 32; i < 64; i++)//明文的右半部分 
        min_r[0][i - 32] = m_b[i];
    exchange(s_a, s_b, zhihuan1, 56);//密钥进行PC-1置换  
    int run = 1;
    for (i = 0; i < 28; i++) {
        key_l[0][i] = s_b[i];
        key_r[0][i] = s_b[i + 28];
    }
    int n;
    for (r = 1; r <= 16; r++) {
        n = get(r);
        left_move(key_l[run], key_l[run - 1], n);
        left_move(key_r[run], key_r[run - 1], n);
        run++;
    }
    //结合 
    for (r = 1; r <= 16; r++) {
        for (i = 0; i < 28; i++) {
            key_2[r][i] = key_l[r][i];
            key_2[r][i + 28] = key_r[r][i];
        }

    }
    //pc-2置换
    int key_3[17][48];
    int	zhihuan2[48] = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 };  //置换2
    for (r = 1; r <= 16; r++) {
        exchange(key_2[r], key_3[r], zhihuan2, 48);
    }
    //真正的16轮密钥到此生成 
    int temp6[48], temp1[32];
    for (r = 1; r <= 16; r++) {
        fuck(min_l[r], min_r[r - 1], 32);//左半部分等于上一轮右半部分 
        exchange(min_r[r - 1], temp6, e, 48);//E置换
        yihuo(temp6, key_3[r], 48);//准备S盒置换 
        s_box(temp1, temp6);//s盒替换完毕 
        exchange(temp1, temp6, p, 32);//P置换 
        yihuo(temp6, min_l[r - 1], 32);
        fuck(min_r[r], temp6, 32);
        cout << "第" << r << "轮加密后的密文为" << endl;
        for (i = 0; i < 32; i++) {
            cout << min_l[r][i];
        }
        for (i = 0; i < 32; i++) {
            cout << min_r[r][i];
        }
        cout << endl;
    }
    int plus1[64] = { 0 };
    int plus2[64] = { 0 };
    for (i = 0; i < 32; i++) {
        plus1[i] = min_r[16][i];
        plus1[i + 32] = min_l[16][i];
    }
    unsigned char plus3[8];
    exchange(plus1, plus2, IP_1, 64);
    erzhuanshi(plus2, plus3, 64);
    cout << "最终密文为" << endl;
    for (i = 0; i < 8; i++) {
        cout << plus3[i];
    }
    //开始解密
    exchange(plus2, plus1, IP, 64);//IP_1置换 
    for (i = 0; i < 32; i++) {
        min_l[16][i] = plus1[i + 32];
        min_r[16][i] = plus1[i];
    }
    cout << endl;
    for (r = 16; r >= 1; r--) {
        fuck(min_r[r - 1], min_l[r], 32);//这一轮的左等于上一轮的右 	
        exchange(min_r[r - 1], plus1, e, 48);//E扩展 
        yihuo(plus1, key_3[r], 48);//与密钥异或
        s_box(plus2, plus1);//S盒置换
        exchange(plus2, plus1, p, 32);//p盒置换
        fuck(min_l[r - 1], plus1, 32);
        yihuo(min_l[r - 1], min_r[r], 32);//异或 
        cout << "第" << 17 - r << "轮解密后的密文为" << endl;
        for (i = 0; i < 32; i++) {
            cout << min_l[r - 1][i];
        }
        for (i = 0; i < 32; i++) {
            cout << min_r[r - 1][i];
        }
        cout << endl;
    }
    for (i = 0; i < 32; i++) {
        plus1[i + 32] = min_r[0][i];
        plus1[i] = min_l[0][i];
    }
    exchange(plus1, plus2, IP_1, 64);
    cout << "解密后的密文为" << endl;
    int min_re[64];
    unsigned char min_plus[16];
    erzhuanshi(plus2, min_plus, 64);
    for (i = 0; i < 8; i++) {
        cout << min_plus[i];
    }
    cout << endl;
    fuck(min_re, plus2, 64);
    int flag = 0;
    for (i = 0; i < 64; i++) {
        if (m_a[i] != min_re[i]) {
            flag = 1;
            break;
        }
    }
    if (flag == 0) {
        cout << "解密成功";
    }
    else {
        cout << "解密失败";
    }
}